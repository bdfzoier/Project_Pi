 # **计算π - 学段汇报**
开源项目网址: [https://github.com/bdfzoier/Project_Pi](https://github.com/bdfzoier/Project_Pi)
开发团队: [https://github.com/bdfzoier](https://github.com/bdfzoier)
- ### **π的历史**
众所周知，**π**是一个**无理数**，其定义为一个半径不为0的圆的**周长**和**直径**的**比值**，和自然界中很多事物都有很强的联系。然而由于**π**是一个**无理数**，所以我们并不能很快的计算出来，必须通过特定的方法进行研究计算。

古巴比伦，古埃及的数学大佬们大概通过实验得出了一个比较准确的数。然而这些大佬们过于嚣张，认为自己一直是对的……于是他们就得出了结论：`π=25/8=3.125`和`π=16/9=3/16.05`…… 然而这样做的精度实在是不够，于是就造成了后来一大堆数学家对他们结论的疯狂驳回。

接下来不到一个世纪，中国的一本古算书中写了径一而周三，也就是`π=3`。同时，古希腊的大数学家阿基米德用几何法先算出了π的下界为3，随后不断加多边数计算，计算出了`π≈3.141851`。

又过了四个世纪，南北朝时期的著名 **数学家 科学家** 祖冲之采用了用多边形来接近圆后而计算的方法，经过了两天两夜……以及几麻袋算筹的可观计算，得出了**π**位于**3.1415926**和**3.1415927**之间。这个纪录在好几个世纪中都没有人进行突破。

直到1948年，人类一直都在用人肉计算π，计算的精度达到了可观的**808**位。现在随着计算机技术的飞速发展，我们计算出来的π精度不断地撑破原来的极限，直冲**10000000000000**位。现在，我们决定追寻昨天巨人的脚步，通过编写程序的方式，计算π。

- ### **我们对π的计算**

然而由于π的计算实在不是什么美差事，我们找了许多方法。举个例子：**BBP**（Bailey Borwein Plouffle's algorithm）。BBP相当于π的通项公式，但是因为它……它居然是16进制的，我们不打算予以优先考虑。

我们采取的优先方法是**均匀撒点**和**随机撒点**法。均匀撒点法的准确性更好，而且不用随机生成万恶的`srand() + rand()`，所以随机撒点法就被我们排除了。

- #### 高精度double型

由于计算精度原因，原来的`double`型是肯定不能撑住。于是我们搞了一个结构体起名`lld (long long double)`，再重载了一下运算符……主体代码如下：

这里面有加减乘除（高精/高精 & 高精/低精）以及输入输出和简单的比较，并使用struct封装。
为了增强此数据类型扩展性，减少空间占用，将用于读入的char数组设为静态的。

[Long_Long_Double Template](https://ghostbin.com/paste/kxtu7) 

Developers : GYH[Developer]、ZZEH[Developer]、LTT[Debug]

- #### 计算π的算法
- #### **均匀撒点法**

均匀撒点法(或微积分法)，就是将一块面积中均匀模拟放置点，再利用勾股定理判断一个点是否在圆里，接下来利用高精度来计算比值。（**注：撒的点越多，π的精度就越高**）
**原理:**
[![圆周率-微积分.png](https://i.loli.net/2019/01/03/5c2d71ffae2e5.png)](https://i.loli.net/2019/01/03/5c2d71ffae2e5.png)
在右上角的四分之一圆中，对于每个y，都有一个对应的x，使得点(x,y)在圆弧上。并且点(x,y)到原点的距离为r，有勾股定理可得$r=sqrt(x^2+y^2)$，即$x^2+y^2<=r^2$为点(x,y)在四分之一圆内的充要条件。
由此可得计算四分之一圆内点数的公式为：
$π = 4*(sqrt(n^2-1^2)+sqrt(n^2-2^2)+sqrt(n^2-3^2)+...+sqrt(n^2-n^2))/n^2$
~~其实本公式也可以理解为微积分求圆的面积~~

**格雷戈里 - 莱布尼茨无穷级数:**

最简单的无穷级数，即格雷戈里-莱布尼茨数。尽管计算较费时间，但每一次迭代的结果都会更接近 Pi 的精确值，迭代 500,000 次后可准确计算出 Pi 的 10 位小数。公式如下：
`π = (4/1) - (4/3) + (4/5) - (4/7) + (4/9) - (4/11) + (4/13) - (4/15)`

[Gregory Leibniz's Algorithm](https://ghostbin.com/paste/uzcyn)

Developers : ZZEH[Developer]、LTT[Developer]

**Nilakantha 级数**
逼近速度比第一个级数更快，且更加广为人知。n=10000时精确到3.1415926535897932，但是效率仍不够高。
`π = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) + 4/(10*11*12) - (4/(12*13*14) ...`

[Nilakantha's Algorithm](https://ghostbin.com/paste/qnpvd)

Developers : GYH[Developer]

**一个逼近最快的无名级数**

一个相对小众的级数，但效率极高。
这个算法在n=40左右的时候pi便可以精确到3.14159265358979
n1e7时前25000位准确无误，我们的主力算法之一！

`π = 1+1/3+1/3*2/5+1/3*2/5*3/7……+1*2*3*……n/3*5*……*(2n+1)`

[QuickPi Algorithm](https://ghostbin.com/paste/f56sz)

Developers : ZZEH[CppDev + PyDev]

- #### **BBP公式**

BBP公式是一个可以快速计算出π在16进制意义下固定位的公式，它在计算π的值时也有很高的效率。

[Bailey Borwein Plouffle's algorithm](https://ghostbin.com/paste/c9mf3)

Developers : XZH[Developer]

**BBP公式的样子**
`π=sum of (1/16^k) * (4/8k+1 - 2/8k+4 - 1/8k-5 - 1 / 8k-6) for all k∈N`
每一项中都有一个`1/16^k`，所以它有能力计算π在16进制下的固定位。

当我们将公式改成`π=sum of (1/16^k) * (4/8k+1 - 2/8k+4 - 1/8k-5 - 1 / 8k-6) for all k∈{0,1,2,3,4,...,n} (n∈N)`时，显然随着n的增大，该公式算出来的π值也会变的更加精确。在n=12时算出来的π可以达到`3.14159265358979323`的精确度。
- ### **参考文献**

- [5种方法来计算圆周率 Pi](https://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87-Pi)
- [BBP算法板子](https://blog.csdn.net/zxy160/article/details/78470702)
- [圆周率pi的BBP计算公式之详细证明](https://wenku.baidu.com/view/716dbac708a1284ac85043bf.html)
- [计算圆周率 Pi (π) 值, 精确到小数点后 10000 位 只需要 30 多句代码！](http://www.cppfans.com/articles/basecalc/c_pi_10000.asp)
- [用c++高精度的计算π的值，可精确到n位](https://blog.csdn.net/qin_zhangyongheng/article/details/8033942)
- [高精度原理](https://oi-wiki.org/math/bignum/)
- [标准pi值](https://www.piday.org/million/)