# **计算π - 学段汇报**
开源项目网址: [https://github.com/bdfzoier/Project_Pi](https://github.com/bdfzoier/Project_Pi)
开发团队: [https://github.com/bdfzoier](https://github.com/bdfzoier)

## 作者：郭一航  李天桐 谢梓涵 周翟恩和
## 分工：
**代码分工：**

- 高精度：郭一行 周翟恩和
- 其他算法：周翟恩和
- BBP：谢梓涵
- 代码测试：李天桐 谢梓涵

**论文：**

- 高精度除法：周翟恩和
- 高斯-勒让德算法：郭一航
- 微积分算法： 周翟恩和
- BBP：谢梓涵
- 其他：李天桐

指导教师：肖然

（以上作者不分先后，按姓名拼音顺序排列）


- ### **概括**
我们这次学段汇报对π的历史进行了深刻的研究，从原始的手算到现在的世界纪录基本上都被我们一览无余。经过了对历史上人们计算π的方法的研究，我们自己利用唾手可得的C++编了一系列程序，其中算法包括BBP，高精度等。经过了几周的编程，我们成功地将π的精度锁定在了25000位以后。利用一个很简单的程序，即可求出圆的直径和周常的神奇关系。

- ### **π的历史**
众所周知，**π**是一个**无理数**，其定义为一个半径不为0的圆的**周长**和**直径**的**比值**，和自然界中很多事物都有很强的联系。然而由于**π**是一个**无理数**，所以我们并不能很快的计算出来，必须通过特定的方法进行研究计算。

古巴比伦，古埃及的数学大佬们大概通过实验得出了一个比较准确的数。然而这些大佬们过于嚣张，认为自己一直是对的……于是他们就得出了结论：`π=25/8=3.125`和`π=16/9=3/16.05`…… 然而这样做的精度实在是不够，于是就造成了后来一大堆数学家对他们结论的疯狂驳回。

接下来不到一个世纪，中国的一本古算书中写了径一而周三，也就是`π=3`。同时，古希腊的大数学家阿基米德用几何法先算出了π的下界为3，随后不断加多边数计算，计算出了`π≈3.141851`。

又过了四个世纪，南北朝时期的著名 **数学家 科学家** 祖冲之采用了用多边形来接近圆后而计算的方法，经过了两天两夜……以及几麻袋算筹的可观计算，得出了**π**位于**3.1415926**和**3.1415927**之间。这个纪录在好几个世纪中都没有人进行突破。

直到1948年，人类一直都在用人肉计算π，计算的精度达到了可观的**808**位。现在随着计算机技术的飞速发展，我们计算出来的π精度不断地撑破原来的极限，直冲**10000000000000**位。现在，我们决定追寻昨天巨人的脚步，通过编写程序的方式，计算π。

### **我们对π的计算**

然而由于π的计算实在不是什么美差事，我们找了许多方法。举个例子：**BBP**（Bailey Borwein Plouffle's algorithm）。BBP相当于π的通项公式，但是因为它……它居然是16进制的，我们不打算予以优先考虑。

我们采取的优先方法是**均匀撒点**和**随机撒点**法。均匀撒点法的准确性更好，而且不用随机生成万恶的`srand() + rand()`，所以随机撒点法就被我们排除了。

#### 高精度double型

由于计算精度原因，原来的14位`double`型是肯定不能撑住。于是我们搞了一个结构体起名`lld (long long double)`，再重载了一下各种运算符……主体代码如下：

这里面有加减乘除（高精/高精 & 高精/低精）以及输入输出和简单的比较，并使用struct封装。
为了增强此数据类型扩展性，减少空间占用，将用于读入的char数组设为静态的。

[Long_Long_Double Template](https://ghostbin.com/paste/kxtu7) 

Developers : GYH[Developer]、ZZEH[Developer]、LTT[Debug]

高精度的存储其实非常简单。首先，我们读进去一个字符串，然后倒序将每一位存贮在数组内，每一位数对应一个下标。
倒序存储是有原因的。当计算机读进来字符串时，第一位是最高位。为了方便计算，我们需要将最低位存储在 1 位（或者第 0 位）。
高精度加减乘就先不说了，毕竟都相对简单，只需模拟大家平时列竖式的过程即可。
而高精度除法则有些挑战了，以160.14除以3.14为例子来介绍一下高精除的过程：
```
首先将3.14转换成314
接着开始列竖式
设一个高精度变量o为每次除法的被除数
高精度变量q为存储结果的变量

第一次：
    o=1(160.14的第一位)
    发现o比314小，所以跳过

第二次：
    o=16(加上160.14的下一位)
    发现o还是比314小，所以跳过

第三次：
    o=160(加上160.14的下一位)
    发现o还是比314小，所以跳过

第四次：
    o=1601(加上160.14的下一位)
    o比314大，所以在o>=314时重复执行：
        o=o-314;
        计数器+1;
    o=31
    计数器的结果为5
    将5填到q的十位上。

第五次：
    o=314(上一次的余数加上下一位)
    o>=314，所以在o>=314时重复执行：
        o=o-314;
        计数器+1;
    计数器结果为1
    将1填到个位上。

计算结束，q=51。
```

#### 计算π的算法
**均匀撒点法**

均匀撒点法(或微积分法)，就是将一块面积中均匀模拟放置点，再利用勾股定理判断一个点是否在圆里，接下来利用高精度来计算比值。（**注：撒的点越多，π的精度就越高**）

**原理:**

[![圆周率-微积分.png](https://i.loli.net/2019/01/03/5c2d71ffae2e5.png)](https://i.loli.net/2019/01/03/5c2d71ffae2e5.png)

在右上角的四分之一圆中，对于每个y，都有一个对应的x，使得点(x,y)在圆弧上。并且点(x,y)到原点的距离为r，有勾股定理可得$r=sqrt(x^2+y^2)$，即$x^2+y^2<=r^2$为点(x,y)在四分之一圆内的充要条件。
由此可得计算四分之一圆内点数的公式为：
$π = \frac{4\times(\sqrt{n^2-1^2}+\sqrt{n^2-2^2}+\sqrt{n^2-3^2}+...+\sqrt{n^2-(n-1)^2})}{n^2}$
~~其实本公式也可以理解为微积分求圆的面积~~

**格雷戈里 - 莱布尼茨无穷级数:**

最简单的无穷级数，即格雷戈里-莱布尼茨数。尽管计算较费时间，但每一次迭代的结果都会更接近 Pi 的精确值，迭代 500,000 次后才可准确计算出 Pi 的 10 位小数。公式如下：
$\frac{\pi}{4} = \sum^{∞}_{n=0}\frac{(-1)^n}{2n+1}$

证明：

考虑下面的分解：$\frac{1}{1+x^2}=\sum^{n}_{i=0}(-1)^ix^{2i} + \frac{(-1)^{n+1}x^{2n+2}}{1+x^2}$




[Gregory Leibniz's Algorithm](https://ghostbin.com/paste/uzcyn)

Developers : ZZEH[Developer]、LTT[Developer]

**Nilakantha 级数**
逼近速度比第一个级数更快，且更加广为人知。n=10000时精确到3.1415926535897932，但是效率仍不够高。
$π = 3 + \frac4{2\times3\times4} - \frac4{4\times5\times6} + \frac4{6\times7\times8} - \frac4{8\times9\times10} + \frac4{10\times11\times12} - \frac4/{12\times13\times14} ...$

[Nilakantha's Algorithm](https://ghostbin.com/paste/qnpvd)

Developers : GYH[Developer]

**Gauss–Legendre算法**
高斯-勒让德算法是一种用于计算π的算法。它以迅速收敛著称，只需25次迭代即可产生π的4500万位正确数字。不过，它的缺点是内存密集，因此有时它不如梅钦类公式使用广泛。
该方法基于卡尔·弗里德里希·高斯（1777–1855）和阿德里安-马里·勒让德（1752–1833）的个人成果与乘法和平方根运算的现代算法的结合。该算法反复替换两个数值的算术平均数和几何平均数，以接近它们的算术-几何平均数。
初始值为
$a_0=1\quad b_0=\frac{1}{\sqrt2}\quad t_0=\frac{1}{4}\quad p_0=1$
随后每次迭代：
$a_{n+1}=\frac{a_n+b_n}{2}$

$b_{n+1}=\sqrt{a_nb_n}$

$t_{n+1}=t_n-p_n(a_n-a_{n+1})^2$

$p_{n+1}=2p_n$

$\pi\approx\frac{(a_{n+1}+b_{n+1})^2}{4t_{n+1}}$
Developers : GYH[CppDev]

**一个逼近最快的无名级数**

一个相对小众的级数，但效率极高。
这个算法在n=40左右的时候pi便可以精确到3.14159265358979
n1e7时前25000位准确无误，我们的主力算法之一！
同时它可以省去高精度数相乘和相除这种不方便、代码长且速度慢的算法，计算方便。

`π = 1+1/3+1/3*2/5+1/3*2/5*3/7……+1*2*3*……n/3*5*……*(2n+1)`

[QuickPi Algorithm](https://ghostbin.com/paste/f56sz)

Developers : ZZEH[CppDev + PyDev]

- #### **BBP公式**

BBP公式是一个可以快速计算出π在16进制意义下固定位的公式，它在计算π的值时也有很高的效率。

[Bailey Borwein Plouffle's algorithm](https://ghostbin.com/paste/c9mf3)

Developers : XZH[Developer]

**BBP公式的样子**
$\pi=\sum\limits_{k=0}^N (\frac{1}{16^k})(\frac{4}{8k+1} - \frac{2}{8k+4} - \frac{1}{8k-5} - \frac{1}{8k-6})$
每一项中都有一个`1/16^k`，所以它有能力计算π在16进制下的固定位。

当我们将公式改成$\pi=\sum\limits_{k=0}^n (\frac{1}{16^k})(\frac{4}{8k+1} - \frac{2}{8k+4} - \frac{1}{8k-5} - \frac{1}{8k-6})$ (n∈N)时，显然随着n的增大，该公式算出来的π值也会变的更加精确。在n=12时算出来的π可以达到`3.14159265358979323`的精确度，论n较小时相对效率，BBP公式比“无名级数”。
- ### **成果**(以下结果均由基于无名级数的算法算出)
[n=1e6,10000位小数](https://raw.githubusercontent.com/bdfzoier/Project_Pi/master/result/n1e6%2Clen1e4.txt)
[n=2e7,30000位小数](https://raw.githubusercontent.com/bdfzoier/Project_Pi/master/result/n2e7%2Clen3e4.txt)
- ### **参考文献**

- [5种方法来计算圆周率 Pi](https://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87-Pi)
- [BBP算法板子](https://blog.csdn.net/zxy160/article/details/78470702)
- [圆周率pi的BBP计算公式之详细证明](https://wenku.baidu.com/view/716dbac708a1284ac85043bf.html)
- [计算圆周率 Pi (π) 值, 精确到小数点后 10000 位 只需要 30 多句代码！](http://www.cppfans.com/articles/basecalc/c_pi_10000.asp)
- [用c++高精度的计算π的值，可精确到n位](https://blog.csdn.net/qin_zhangyongheng/article/details/8033942)
- [高精度原理](https://oi-wiki.org/math/bignum/)
- [标准pi值](https://www.piday.org/million/)
- [高斯-勒让德算法](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF-%E5%8B%92%E8%AE%A9%E5%BE%B7%E7%AE%97%E6%B3%95)